// Define what you want `currentUser` to return throughout your app. For example,
// to return a real user from your database, you could do something like:
//
//   export const getCurrentUser = async ({ email }) => {
//     return await db.user.findOne({ where: { email } })
//   }
//
// If you want to enforce role-based access, you'll need to set the
// currentUser's roles attributes to the collection of roles as defined by your app.
//
// This allows requireAuth() on the api side and hasRole() in the useAuth() hook on the web side
// to check if the user is assigned a given role or not.
//
// How you set the currentUser's roles depends on your auth provider and its implementation.
//
// If for example, your decoded JWT stores `roles` in its `app_metadata`:
//
// {
//   'https://example.com/app_metadata': { authorization: { roles: ['admin'] } },
//   'https://example.com/user_metadata': {},
//   iss: 'https://app.us.auth0.com/',
//   sub: 'email|1234',
//   aud: [
//     'https://example.com',
//     'https://app.us.auth0.com/userinfo'
//   ],
//   iat: 1596481520,
//   exp: 1596567920,
//   azp: '1l0w6JXXXXL880T',
//   scope: 'openid profile email'
// }
//
// Roles are defined in the decoded token's app_metadata.
// The parseJWT utility will extract the roles from decoded token.
//
// The app_medata claim may or may not be namespaced based on the auth provider.
// Note: Auth0 requires namespacing custom JWT claims
//
// Some providers, such as with Auth0, will set roles an authorization
// attribute in app_metadata (namespaced or not):
//
// 'app_metadata': { authorization: { roles: ['publisher'] } }
// 'https://example.com/app_metadata': { authorization: { roles: ['publisher'] } }
//
// other providers may include roles simply within app_metadata
//
// 'app_metadata': { roles: ['author'] }
// 'https://example.com/app_metadata': { roles: ['author'] }
//
// and yet other may define roles as a custom claim at the root of the decoded token.
//
// roles: ['admin']
//
// You have options how to fetch the currentUser and set roles based on your app implemention:
//
//   export const getCurrentUser = async (decoded) => {
//     return {
//       ...decoded,
//       roles: parseJWT({ decoded: decoded }).roles,
//     }
//   }
//
// ... or
//
//   export const getCurrentUser = async (decoded) => {
//     const currentUser = await db.user.findOne({ where: { email: decoded.email } })
//
//     return {
//       ...currentUser,
//       roles: parseJWT({ decoded: decoded, namespace: NAMESPACE }).roles,
//     }
//   }
//
// ... or
//
//   const getCurrentUser = async (decoded) => {
//     const currentUser = await db.user.findOne({ where: { userIdentity: decoded.sub } })
//     return {
//       ...currentUser,
//       roles: parseJWT({ decoded: decoded }).roles,
//     }
//   }
//
// Whichever implementation you require, your currentUser should have a collection of roles
// so that requireAuth() on the api side and hasRole() in useAuth() on the web side
// can check currentUser for role assignment
//
//   currentUser.roles = []

import { AuthenticationError, ForbiddenError, parseJWT } from '@redwoodjs/api'

export const getCurrentUser = async (decoded, { _token, _type }) => {
  return decoded
}

// Use requireAuth in your services to check that a user is logged in,
// whether or not they are assigned a role, and optionally raise an
// error if they're not.

export const requireAuth = ({ role }) => {
  if (!context.currentUser) {
    throw new AuthenticationError("You don't have permission to do that.")
  }

  if (role && !context.currentUser.roles?.includes(role)) {
    throw new ForbiddenError("You don't have access to do that.")
  }
}
